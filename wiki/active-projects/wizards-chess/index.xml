<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Purdue ARC â€“ Wizard's Chess</title><link>https://purduearc.com/wiki/active-projects/wizards-chess/</link><description>Recent content in Wizard's Chess on Purdue ARC</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 30 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://purduearc.com/wiki/active-projects/wizards-chess/index.xml" rel="self" type="application/rss+xml"/><item><title>Wiki: Software</title><link>https://purduearc.com/wiki/active-projects/wizards-chess/software/</link><pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate><guid>https://purduearc.com/wiki/active-projects/wizards-chess/software/</guid><description>
&lt;h2 id="system-overview">System Overview&lt;/h2>
&lt;pre tabindex="0">&lt;code class="language-mermaid" data-lang="mermaid">graph
subgraph High Level
HL1[Trajectory Planner]
HL2[Voice Recognition]
end
subgraph Chess Piece Robot
direction LR
LL1[Differential Drive Controller]
LL2[Driver]
LL3[Motors]
end
subgraph Vision
direction LR
V1[Apriltag Localization]
end
subgraph Control
C1[Trajectory Execution ROS nodes]
end
%% Low level
LL1 --&amp;gt; LL2
LL2 --&amp;gt; LL3
%% Behavior Planning
HL2 --&amp;gt; HL1
HL1 --&amp;gt; C1
%% Vision
V1 --&amp;gt; C1
V1 --&amp;gt; HL1
%% Control
C1 --&amp;gt; LL1
%% Links
click LL1 href &amp;#34;http://wiki.purduearc.com/wiki/wizards-chess/software#differential-drive-controller&amp;#34; &amp;#34;Label&amp;#34;
click C1 href &amp;#34;http://wiki.purduearc.com/wiki/wizards-chess/software#trajectory-execution-controller&amp;#34; &amp;#34;Label&amp;#34;
click HL1 href &amp;#34;http://wiki.purduearc.com/wiki/wizards-chess/software#trajectory-planner&amp;#34; &amp;#34;Label&amp;#34;
click HL2 href &amp;#34;http://wiki.purduearc.com/wiki/wizards-chess/software#voice-recognition&amp;#34; &amp;#34;Label&amp;#34;
click V1 href &amp;#34;http://wiki.purduearc.com/wiki/wizards-chess/software#apriltag-localization&amp;#34; &amp;#34;Label&amp;#34;
classDef not_started fill:#ff8181
classDef in_progress fill:#ffba82
classDef done fill:#81ff9b
class V1,HL1,HL2,LL1,C1 not_started
%% class C1 in_progress
class LL2,LL3 done
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code class="language-mermaid" data-lang="mermaid">graph
l1[Not Started]
l2[In Progress]
l3[Done]
classDef not_started fill:#ff8181
classDef in_progress fill:#ffba82
classDef done fill:#81ff9b
class l1 not_started
class l2 in_progress
class l3 done
&lt;/code>&lt;/pre>&lt;h2 id="high-level">High Level&lt;/h2>
&lt;h3 id="voice-recognition">Voice Recognition&lt;/h3>
&lt;h4 id="problem">Problem&lt;/h4>
&lt;p>Given a voice command such as &amp;ldquo;Knight to e4&amp;rdquo;, generate a machine readable command that can be inputted to the Trajectory Planner.&lt;/p>
&lt;h4 id="potential-approach">Potential Approach&lt;/h4>
&lt;p>Can use python-based speech recognition libraries to output raw text, which can easily be converted to a &lt;a href="">ROS message&lt;/a> that is consumed by the Trajectory Planner&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-mermaid" data-lang="mermaid">graph LR
A1[Voice Input]
A2[Speech Recognition Python Library]
A3[ROS wrapper node]
A4[Behavior Planner]
A1 --&amp;gt; A2
A2 --&amp;gt; A3
A3 --&amp;gt; A4
&lt;/code>&lt;/pre>&lt;h4 id="related">Related&lt;/h4>
&lt;ul>
&lt;li>&lt;a href="https://wiki.purduearc.com/wiki/wizards-chess/software#ros">ROS&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wiki.purduearc.com/wiki/wizards-chess/software#python">Python&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/Uberi/speech_recognition">SpeechRecognition Python Library&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="trajectory-planner">Trajectory Planner&lt;/h3>
&lt;h4 id="problem-1">Problem&lt;/h4>
&lt;p>Given that we have just a camera which can localize (know the position of) each chess piece and find the center of any empty board square, how do we describe the movement of a chess piece from one square to another to complete a move using information we can actually execute on the robot, while not creating a collision with another piece?&lt;/p>
&lt;h4 id="potential-approach-1">Potential Approach&lt;/h4>
&lt;p>Since our input to the system is in pixels, we can:&lt;/p>
&lt;ol>
&lt;li>Query the x,y position of where the piece starts and ends&lt;/li>
&lt;li>Create a time-dependent, x,y-coordinate-valued trajectory between the two x,y positions (could be as simple as a straight line)&lt;/li>
&lt;li>If the above trajectory results in a collision (can be determined using the distance formula between pieces and knowing the radius of each piece), create a trajectory for the other piece to move out of the way. (Take a look at flocking algorithms, linked below)&lt;/li>
&lt;li>Now that we have a set of trajectories, send them to the trajectory execution node of each respective chess piece to be executed concurrently&lt;/li>
&lt;/ol>
&lt;h4 id="related-1">Related&lt;/h4>
&lt;ul>
&lt;li>&lt;a href="https://wiki.purduearc.com/wiki/wizards-chess/software#ros">ROS&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wiki.purduearc.com/wiki/wizards-chess/software#python">Python&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wiki.purduearc.com/wiki/wizards-chess/software#opencv">OpenCV&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://codeheir.com/2021/03/27/the-flocking-algorithm/">Flocking Algorithm&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="vision">Vision&lt;/h2>
&lt;h3 id="apriltag-localization">Apriltag Localization&lt;/h3>
&lt;h4 id="problem-2">Problem&lt;/h4>
&lt;p>How can we determine the position of each chess piece and every empty square on the board?&lt;/p>
&lt;h4 id="potential-approach-2">Potential Approach&lt;/h4>
&lt;p>Apriltags are a simple way to solve this accurately. With just an Apriltag on the four corners of the board (still need to measure square size manually) and an Apriltag on each chess piece, we can determine the xyz position of the entire system.&lt;/p>
&lt;h4 id="related-2">Related&lt;/h4>
&lt;ul>
&lt;li>&lt;a href="https://wiki.purduearc.com/wiki/wizards-chess/software#ros">ROS&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/AprilRobotics/apriltag_ros">Apriltag ROS library&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://april.eecs.umich.edu/software/apriltag.html">Apriltag website&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="control">Control&lt;/h2>
&lt;h3 id="trajectory-execution-controller-nodes">Trajectory Execution Controller Nodes&lt;/h3>
&lt;h4 id="problem-3">Problem&lt;/h4>
&lt;p>How do we ensure that the robot is correctly executing the trajectory given by the Trajectory Planner, and if it is inaccurate, how do we control for it?&lt;/p>
&lt;h4 id="potential-approach-3">Potential Approach&lt;/h4>
&lt;p>Fortunately, we can look at control theory to give us a good solution: an LQR controller. This essentially is an optimization algorithm with weighted costs that the algorithm minimizes.&lt;/p>
&lt;p>Also, a Pure Pursuit algorithm may be used as well.&lt;/p>
&lt;p>For any algorithm, the inputs are the trajectory itself, the current localized position of the chess piece, the target position, and the output is a &lt;a href="http://docs.ros.org/en/api/geometry_msgs/html/msg/Twist.html">Twist&lt;/a> ROS message velocity command (the linear and angular velocity of the robot).&lt;/p>
&lt;p>This would be running on the master computer that has access to camera input and the will be communicated to each robot as there will be a trajectory execution node for each robot.&lt;/p>
&lt;h4 id="related-3">Related&lt;/h4>
&lt;ul>
&lt;li>&lt;a href="https://wiki.purduearc.com/wiki/wizards-chess/software#ros">ROS&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wiki.purduearc.com/wiki/wizards-chess/software#python">Python&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wiki.purduearc.com/wiki/wizards-chess/software#c++">C++&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://sophistt.github.io/2020/05/02/lqr-controller-theory/">LQR Controller&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vinesmsuic.github.io/2020/09/29/robotics-purepersuit/#theoretical-derivation">Pure Pursuit Algorithm&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="robot">Robot&lt;/h2>
&lt;h3 id="differential-drive-controller">Differential Drive Controller&lt;/h3>
&lt;h4 id="problem-4">Problem&lt;/h4>
&lt;p>The robot motors don&amp;rsquo;t understand what Twist linear/angular velocity is, just the speed and direction at which they need to spin. So how do we convert the Twist to individual motor speeds (just a value between 0-255)?&lt;/p>
&lt;h4 id="potential-approach-4">Potential Approach&lt;/h4>
&lt;p>For different types of steering geometries, there are different control algorithms used to steer mobile vehicles (Skid-steer, Ackermann, differential drive, etc).&lt;/p>
&lt;p>For our robot, it is a differential drive steering configuration, specific to the geometry of two wheels on either side and a caster wheel for stability.&lt;/p>
&lt;p>This would be running on the robot.&lt;/p>
&lt;h4 id="related-4">Related&lt;/h4>
&lt;ul>
&lt;li>&lt;a href="https://wiki.purduearc.com/wiki/wizards-chess/software#ros">ROS&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wiki.purduearc.com/wiki/wizards-chess/software#python">Python&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wiki.purduearc.com/wiki/wizards-chess/software#c++">Arduino/C++&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://wiki.ros.org/diff_drive_controller">Differential Drive Controller ROS Package&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=aE7RQNhwnPQ&amp;amp;list=PLp8ijpvp8iCvFDYdcXqqYU5Ibl_aOqwjr&amp;amp;index=10">Differential Drive Robots lecture - recommended for understanding theory&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="problems-not-described-yet">Problems not described yet&lt;/h2>
&lt;ul>
&lt;li>Structuring the robot-level systems so they are modular and can easily spawned for all the chess pieces.&lt;/li>
&lt;li>Ensuring that the system is controlled (i.e cameras can see all apriltags at all times, etc)&lt;/li>
&lt;li>Playing against an engine&lt;/li>
&lt;li>Simplifying the interface with a human (app?, website?)&lt;/li>
&lt;/ul>
&lt;h1 id="resources">Resources&lt;/h1>
&lt;h2 id="tools">Tools&lt;/h2>
&lt;h3 id="ros">ROS&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://wiki.purduearc.com/wiki/tutorials/snake-tutorial">ARC ROS tutorials (Recommended)&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://wiki.ros.org/ROS/Tutorials">Official ROS tutorials&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="github">GitHub&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://www.freecodecamp.org/news/learn-the-basics-of-git-in-under-10-minutes-da548267cc91/">Learn Git under 10 min&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="c">C++&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=18c3MTX0PK0&amp;amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb">In depth tutorial playlist for C++&lt;/a>
&lt;ul>
&lt;li>Recommended:
&lt;ul>
&lt;li>if/else, loops, functions, classes&lt;/li>
&lt;li>Pointers/References&lt;/li>
&lt;li>Smart pointers&lt;/li>
&lt;li>Dynamic Arrays (std::vector)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Very useful numeric libraries
&lt;ul>
&lt;li>&lt;a href="https://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen&lt;/a>: Extremely efficient matrix math library&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="python">Python&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=rfscVS0vtbw">Tutorial&lt;/a>&lt;/li>
&lt;li>Important to understand:
&lt;ul>
&lt;li>Basics are good - variables + logic, functions, classes&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="numpy">Numpy&lt;/h3>
&lt;blockquote>
&lt;p>Must use when working with large arrays (i.e images)&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=8Y0qQEh7dJg">Tutorial&lt;/a>&lt;/li>
&lt;li>Important to understand:
&lt;ul>
&lt;li>Creating arrays&lt;/li>
&lt;li>slicing + indexing&lt;/li>
&lt;li>reshaping&lt;/li>
&lt;li>linear algebra&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="opencv">OpenCV&lt;/h2>
&lt;blockquote>
&lt;p>Use for computer vision and image transformations like color detection, tracking, etc&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=oXlwWbU8l2o">Tutorial&lt;/a>&lt;/li>
&lt;li>Important to understand:
&lt;ul>
&lt;li>image transformation&lt;/li>
&lt;li>thresholding&lt;/li>
&lt;li>read/write images from file&lt;/li>
&lt;li>resizing&lt;/li>
&lt;li>tracking&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Wiki: Hardware</title><link>https://purduearc.com/wiki/active-projects/wizards-chess/hardware/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://purduearc.com/wiki/active-projects/wizards-chess/hardware/</guid><description>
&lt;h2 id="chess-pieces">Chess Pieces&lt;/h2>
&lt;h3 id="design">Design&lt;/h3>
&lt;p>Our current prototype design for the chess pieces has a wooden triangle base, 1&amp;quot; ball bearings, two wheels, and two motors. This was chosen to optimize efficiency, while lowering cost, since we have to build 32 chess pieces. The chess pieces themselves are 9.75&amp;quot; x 7.75&amp;quot; x .5&amp;quot;, designed for maneuverability on the chess board, so that they can move between other chess pieces and we don&amp;rsquo;t have to worry about moving other pieces out of the way. We are also using &lt;a href="https://www.pitsco.com/TETRIX-DC-Gear-Motor">TETRIX Motors&lt;/a> and &lt;a href="https://www.andymark.com/products/neverest-series-motor-only">Neverest Motors&lt;/a>.&lt;/p>
&lt;!--confirm that these are the correct links to the motors-->
&lt;img src="https://purduearc.com/wiki/active-projects/wizards-chess/images/cad-v1.png" alt="CAD Model of Chess Piece V1" width="600"/>
&lt;blockquote>
&lt;p>Other designs have included an X-drive, 4-wheel drive, or 3-wheel triangle bot, however they were scrapped due to the cost and more complex systems they would have included.&lt;/p>
&lt;/blockquote>
&lt;h3 id="manufacturing">Manufacturing&lt;/h3>
&lt;p>The chess pieces are made from .5&amp;quot; birch plywood and manufactured using the laser cutting process. The hole markers are also included in the laser cutting process so that we don&amp;rsquo;t have to remeasure where to drill the holes after every cut and to keep everything uniform.&lt;/p>
&lt;p>We will also start manufacturing the motor mounts ourselves to cut down on cost, using the manual mill and CNC machine.&lt;/p>
&lt;img src="https://purduearc.com/wiki/active-projects/wizards-chess/images/laser-cut.png" alt="Laser Cut Lines" width="400"/>
&lt;img src="https://purduearc.com/wiki/active-projects/wizards-chess/images/motor-mount.jpg" alt="CAD Model of Motor Mount" width="400"/>
&lt;h2 id="chess-board">Chess Board&lt;/h2>
&lt;h3 id="design-1">Design&lt;/h3>
&lt;p>Each square for the board is 1.5&amp;rsquo; x 1.5&amp;rsquo; to accomodate for the chess pieces moving around and between each other. It is then painted black and white accordingly.&lt;/p>
&lt;blockquote>
&lt;p>We also considered foam tiles (which would be too expensive) and tape (which is difficult to move).&lt;/p>
&lt;/blockquote>
&lt;h3 id="manufacturing-1">Manufacturing&lt;/h3>
&lt;p>The board is made from 5mm triply and manufactured using the vertical bandsaw. The triply is cut into pieces of 3&amp;rsquo; x 1.5&amp;rsquo; which accomodates 2 squares on the board. Paint and paintbrushes are available in our workspace to paint the board black and white.&lt;/p>
&lt;blockquote>
&lt;p>When manufacturing, the board is cut to exactly 3&amp;rsquo; and then cut in half, so each piece is a little bit smaller that 1.5&amp;rsquo; due to the saw size.&lt;/p>
&lt;/blockquote></description></item><item><title>Wiki:</title><link>https://purduearc.com/wiki/active-projects/wizards-chess/images/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://purduearc.com/wiki/active-projects/wizards-chess/images/</guid><description/></item></channel></rss>